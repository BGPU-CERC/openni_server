<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>depth cloud</title>

    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@v0.149.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@v0.149.0/examples/jsm/"
          }
        }
    </script>

    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <canvas id="c"></canvas>
</body>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const canvas = document.querySelector('#c');
    const renderer = new THREE.WebGLRenderer({ antialias: true, canvas });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const fov = 75;
    const aspect = window.innerWidth / window.innerHeight
    const near = 0.1;
    const far = 3500;
    const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    camera.position.z = -.5;
    camera.position.y = .25;

    const controls = new OrbitControls(camera, renderer.domElement);
    const scene = new THREE.Scene();

    // grid
    const size = 10;
    const divisions = 10;
    const gridHelper = new THREE.GridHelper(size, divisions, "red",);
    scene.add(gridHelper);

    // Create some random points
    const particles = 15_000;
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];

    const color = new THREE.Color();
    const n = 1000, n2 = n / 2; // particles spread in the cube

    for (let i = 0; i < particles; i++) {
        const x = Math.random() * n - n2;
        const y = Math.random() * n - n2;
        const z = Math.random() * n - n2;
        positions.push(x, y, z);

        const vx = (x / n) + 0.5;
        const vy = (y / n) + 0.5;
        const vz = (z / n) + 0.5;
        color.setRGB(vx, vy, vz, THREE.SRGBColorSpace);
        colors.push(color.r, color.g, color.b);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({ size: .001, vertexColors: true });
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    let i = 0;
    const frameRequest = [];
    const sizeof_vertex = 12;
    const p = points.geometry.attributes.position.array;
    const pointsSocket = new WebSocket("ws://localhost:8080");
    
    pointsSocket.onopen = () => {
        pointsSocket.send(frameRequest);
    }
    
    pointsSocket.onmessage = async (event) => {
        const buffer = await event.data.arrayBuffer();
        const view = new DataView(buffer);

        for (let j = 0; j < buffer.byteLength; j += sizeof_vertex) {
            const x = view.getFloat32(j + 0, true);
            const y = view.getFloat32(j + 4, true);
            const z = view.getFloat32(j + 8, true);

            p[i++] = x / 1000;
            p[i++] = y / 1000;
            p[i++] = z / 1000;
    
            i = i % p.length;
        }

        points.geometry.attributes.position.needsUpdate = true
        pointsSocket.send(frameRequest);
    };

    animate();
    function animate() {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }
</script>

</html>